# POLARIS Configuration Optimized for SWITCH System
# ==================================================
# Configuration specifically tuned for SWITCH ML-enabled adaptive system
# with YOLO model switching to maximize utility function.
#
# Key optimizations:
# - Moderate monitoring intervals for YOLO processing patterns
# - Utility-focused verification thresholds
# - Optimized for model switching response characteristics
# - Tuned for utility function maximization (response time + confidence)

# =============================================================================
# NATS Message Bus Configuration
# =============================================================================
nats:
  url: "nats://localhost:4222"

# =============================================================================
# Telemetry Configuration - Optimized for SWITCH Metrics
# =============================================================================
telemetry:
  # SWITCH generates metrics every 30 seconds by default
  stream_subject: "polaris.telemetry.events.stream"
  batch_subject: "polaris.telemetry.events.batch"
  snapshot_subject: "polaris.telemetry.events.snapshots"
  
  # Moderate batch size for SWITCH's less frequent updates
  batch_size: 15
  
  # Longer wait time appropriate for SWITCH's update rate
  batch_max_wait: 5.0
  
  # Moderate queue size for SWITCH
  queue_maxsize: 500
  
  # Enable streaming for adaptation
  stream: true
  
  knowledge_base:
    enabled: true
    buffer_size: 30

# =============================================================================
# Switch-Specific Telemetry Subjects
# =============================================================================
switch_telemetry:
  metrics_subject: "polaris.switch.metrics"
  model_events_subject: "polaris.switch.model_events"
  performance_subject: "polaris.switch.performance"
  utility_subject: "polaris.switch.utility"
  actions_subject: "polaris.switch.actions"

# =============================================================================
# Reasoner Configuration - SWITCH Optimization Scenarios
# =============================================================================
reasoner:
  kernel_request_subject: "polaris.reasoner.kernel.requests"
  
  action_routing:
    enable_verification: true
    default_verification_level: "policy"
    verification_timeout_sec: 10
    verification_failure_action: "retry"

# =============================================================================
# Kernel Configuration - SWITCH Optimized
# =============================================================================
kernel:
  enable_verification: true
  verification_timeout_sec: 10.0
  
  performance:
    max_concurrent_actions: 1  # Serialize model switches for safety
    action_timeout_sec: 30
    health_check_interval_sec: 20

# =============================================================================
# Execution Configuration
# =============================================================================
execution:
  action_subject: "polaris.execution.actions"
  result_subject: "polaris.execution.results"
  metrics_subject: "polaris.execution.metrics"
  decisions_subject: "polaris.execution.decisions"

# =============================================================================
# Verification Configuration - SWITCH Optimized Thresholds
# =============================================================================
verification:
  input_subject: "polaris.verification.requests"
  output_subject: "polaris.verification.results"
  policy_subject: "polaris.verification.policies"
  metrics_subject: "polaris.verification.metrics"
  
  default_timeout_sec: 15
  max_concurrent_verifications: 3
  enable_by_default: true
  
  routing:
    enable_automatic_routing: true
    bypass_action_types: []
    require_verification_for: []  # All model switches should be verified
  
  # SWITCH-Optimized Thresholds
  thresholds:
    max_cpu_utilization: 0.90
    max_memory_utilization: 0.90
    max_disk_utilization: 0.95
    
    # SWITCH-specific performance thresholds
    max_response_time_increase_percent: 100.0  # Allow doubling for accuracy gains
    max_throughput_decrease_percent: 50.0      # Model switches can impact throughput
    
    # SWITCH safety constraints
    min_system_availability: 0.90
    max_error_rate_increase: 0.15
    
    # SWITCH resource allocation
    max_concurrent_actions: 1  # Only one model active at a time
    max_action_duration_minutes: 5
    
    # Model switching frequency
    max_configuration_changes_per_hour: 30
    require_approval_for_changes_affecting_users: false
  
  # SWITCH-Optimized Risk Levels
  risk_levels:
    low:
      verification_level: "basic"
      auto_approve: true
      require_human_approval: false
      
    medium:
      verification_level: "policy"
      auto_approve: true
      require_human_approval: false
      additional_checks: ["resource_impact"]
      
    high:
      verification_level: "policy"
      auto_approve: false
      require_human_approval: false
      additional_checks: ["resource_impact", "simulation"]
      
    critical:
      verification_level: "comprehensive"
      auto_approve: false
      require_human_approval: false
      additional_checks: ["simulation", "rollback_plan"]

# =============================================================================
# Logging Configuration
# =============================================================================
logger:
  name: "polaris"
  level: "INFO"
  format: "pretty"

# =============================================================================
# Digital Twin Configuration - SWITCH Optimized
# =============================================================================
digital_twin:
  nats:
    update_subject: "polaris.digitaltwin.update"
    calibrate_subject: "polaris.digitaltwin.calibrate"
    error_subject: "polaris.digitaltwin.errors"
    queue_group: "digital_twin_workers"
    max_reconnect_attempts: 5
    reconnect_wait_sec: 1
    
    queue_maxsize: 300
    batch_size: 10
    batch_timeout_sec: 2.0
  
  grpc:
    host: "0.0.0.0"
    port: 50051
    max_workers: 4
    max_message_size: 4194304
    keepalive_time_ms: 30000
    keepalive_timeout_ms: 5000
  
  world_model:
    implementation: "bayesian"
    config_path: "bayesian_world_model_config.yaml"
    reload_on_failure: true
    health_check_interval_sec: 30
  
  performance:
    max_concurrent_queries: 10
    query_timeout_sec: 20
    simulation_timeout_sec: 40
  
  debugging:
    log_level: "INFO"
    enable_detailed_logging: false
    log_to_console: true
    log_file: "logs/digital_twin_switch.log"

# =============================================================================
# SWITCH-Specific Verification Constraints
# =============================================================================
switch_verification:
  constraints:
    - id: "switch_valid_model"
      type: "safety"
      severity: "high"
      description: "Ensure only valid YOLO models are selected"
      condition: "params.model in ['yolov5n', 'yolov5s', 'yolov5m', 'yolov5l', 'yolov5x']"
      violation_message: "Invalid YOLO model specified"
      suggested_fix: "Use one of the 5 valid YOLO models"
      
    - id: "switch_cpu_protection"
      type: "resource"
      severity: "high"
      description: "Prevent model switches that would overload CPU"
      condition: "cpu_usage < 90 OR target_model_is_lighter"
      violation_message: "CPU usage too high to switch to heavier model"
      suggested_fix: "Switch to lighter model or wait for CPU to decrease"
      
    - id: "switch_utility_threshold"
      type: "performance"
      severity: "low"
      description: "Prevent switches that would decrease utility"
      condition: "predicted_utility > current_utility * 0.9"
      violation_message: "Model switch would significantly decrease utility"
      suggested_fix: "Consider different model or wait for conditions to change"

  # SWITCH-Specific Policies
  policies:
    - id: "switch_experimentation_policy"
      type: "governance"
      severity: "low"
      description: "Allow experimentation in SWITCH ML research environment"
      conditions:
        - "system_name == 'switch_yolo'"
      violation_message: "SWITCH is designed for ML adaptation experimentation"
      suggested_fix: "Proceed with adaptive actions"
      
    - id: "switch_utility_optimization_policy"
      type: "governance"
      severity: "medium"
      description: "Prioritize utility maximization for SWITCH"
      conditions:
        - "action.predicted_utility > action.current_utility OR action.priority == 'high'"
      violation_message: "Action should improve utility or be high priority"
      suggested_fix: "Ensure action contributes to utility optimization"

# =============================================================================
# SWITCH Performance Targets & Utility Function Parameters
# =============================================================================
switch_targets:
  # Utility function parameters
  utility:
    Rmin: 0.1   # Best response time (seconds)
    Rmax: 1.0   # Worst acceptable response time
    Cmin: 0.5   # Worst acceptable confidence
    Cmax: 1.0   # Best confidence
    wd: 0.5     # Response time weight
    we: 0.5     # Confidence weight
    pdv: 5.0    # Response time penalty scale
    pev: 5.0    # Confidence penalty scale
  
  # Utility thresholds
  target_utility: 0.8           # Target utility level
  low_utility_threshold: 0.4    # Below this triggers adaptation
  critical_utility: 0.2         # Critical level requiring immediate action
  
  # Response time targets (seconds)
  response_time_good: 0.2       # Good response time
  response_time_acceptable: 0.5 # Acceptable response time
  response_time_critical: 0.9   # Critical response time
  
  # Confidence targets
  confidence_low: 0.55           # Low confidence
  confidence_acceptable: 0.75    # Acceptable confidence
  confidence_high: 0.85          # High confidence
  
  # Resource utilization targets
  cpu_utilization_low: 50.0      # Low CPU (can upgrade model)
  cpu_utilization_high: 85.0     # High CPU (should downgrade model)
  cpu_utilization_max: 95.0      # Maximum CPU before forced action
  
  # Model characteristics (benchmarked)
  models:
    yolov5n:
      response_time: 0.05
      confidence: 0.65
      cpu_factor: 1.0
    yolov5s:
      response_time: 0.10
      confidence: 0.75
      cpu_factor: 1.5
    yolov5m:
      response_time: 0.20
      confidence: 0.82
      cpu_factor: 2.5
    yolov5l:
      response_time: 0.40
      confidence: 0.88
      cpu_factor: 4.0
    yolov5x:
      response_time: 0.80
      confidence: 0.92
      cpu_factor: 6.0
  
  # Adaptation responsiveness
  adaptation_response_time_sec: 3   # Target time to respond to utility degradation
  stabilization_time_sec: 1          # Time to allow for model switch effects

# =============================================================================
# Gemini Pro Model Configuration for SWITCH
# =============================================================================
gemini_switch_config:
  model: "gemini-2.5-flash"
  temperature: 0.2  # Lower for deterministic utility optimization
  max_tokens: 4096
  
  # SWITCH-specific system prompt
  system_prompt: |
    You are an expert in ML model management for the SWITCH adaptive YOLO system.
    
    SWITCH System Knowledge:
    - SWITCH runs YOLOv5 object detection with 5 model variants (n, s, m, l, x)
    - Models trade off response time vs confidence (faster = less accurate)
    - Key metrics: image_processing_time (response), confidence, utility, CPU usage
    - Available actions: SWITCH_MODEL (to any of 5 variants)
    - Model switches take ~2-5 seconds to stabilize
    
    Utility Function (MAXIMIZE THIS):
    utility = we*conf_score + wd*rt_score - penalties
    where:
    - conf_score = normalize(confidence, Cmin=0.5, Cmax=1.0)
    - rt_score = 1 - normalize(response_time, Rmin=0.1, Rmax=1.0)
    - we = 0.5, wd = 0.5 (equal weights)
    - penalties for out-of-range values
    Range: [-inf, 1], higher is better
    
    Model Characteristics:
    - yolov5n: RT~0.05s, Conf~0.65 (fastest, lowest accuracy, CPU 1x)
    - yolov5s: RT~0.10s, Conf~0.75 (balanced, CPU 1.5x)
    - yolov5m: RT~0.20s, Conf~0.82 (medium, CPU 2.5x)
    - yolov5l: RT~0.40s, Conf~0.88 (high accuracy, CPU 4x)
    - yolov5x: RT~0.80s, Conf~0.92 (highest accuracy, CPU 6x)
    
    Adaptation Strategies:
    1. High utility (>0.8): Maintain current model, opportunistic upgrades only
    2. Medium utility (0.4-0.8): Consider adjacent models for optimization
    3. Low utility (<0.4): Aggressive optimization, may skip model levels
    4. High CPU (>85%): Must prioritize lighter models regardless
    5. Critical RT (>0.9s): Immediate downgrade to faster model
    6. Low confidence (<0.55) + acceptable RT: Consider heavier model
    7. Balance: Choose model that maximizes expected utility
    
    Your responses should:
    - Explicitly calculate expected utility for candidate models
    - Provide confidence levels (0-1) for recommendations
    - Consider resource constraints (CPU)
    - Explain tradeoffs between speed and accuracy
    - Suggest monitoring metrics to validate adaptation success
    - Think multi-step: what happens after this adaptation?
    
    Remember: Prioritize learning and optimization over extreme conservatism.

# =============================================================================
# Switch Monitor Configuration
# =============================================================================
switch_monitor:
  # Monitoring intervals and collection settings
  monitor_interval: 30.0            # Collect metrics every 30 seconds
  max_history_size: 100             # Keep last 100 metric snapshots
  
  # Metric collection flags
  collect_performance_metrics: true
  collect_system_metrics: true
  collect_model_state: true
  collect_utility_metrics: true
  
  # Switch system connection
  switch_system:
    host: "localhost"
    port: 3001
    timeout: 10.0
    max_retries: 3
    
    # File paths for Switch system integration
    model_file_path: "model.csv"
    monitor_file_path: "monitor.csv"
    knowledge_file_path: "knowledge.csv"
    metrics_file_path: "metrics.csv"
    
    # Monitoring configuration
    monitor_interval: 30.0
    
    # Utility function parameters
    utility:
      Rmin: 0.1     # Best response time (seconds)
      Rmax: 1.0     # Worst acceptable response time
      Cmin: 0.5     # Worst acceptable confidence
      Cmax: 1.0     # Best confidence
      wd: 0.5       # Response time weight
      we: 0.5       # Confidence weight
      pdv: 5.0      # Response time penalty scale
      pev: 5.0      # Confidence penalty scale

# =============================================================================
# Comprehensive Metrics Collection Configuration
# =============================================================================
metrics_collection:
  # Core performance metrics
  performance_metrics:
    - name: "image_processing_time"
      command: "get_latest_metrics"
      unit: "seconds"
      type: "float"
      category: "performance"
      description: "Total time to process a single image"
      
    - name: "model_processing_time"
      command: "get_latest_metrics"
      unit: "seconds"
      type: "float"
      category: "performance"
      description: "Time spent in model inference only"
      
    - name: "confidence"
      command: "get_latest_metrics"
      unit: "ratio"
      type: "float"
      category: "performance"
      description: "Average detection confidence"
      
    - name: "utility"
      command: "get_latest_metrics"
      unit: "score"
      type: "float"
      category: "performance"
      description: "Overall system utility score"
      
    - name: "detection_boxes"
      command: "get_latest_metrics"
      unit: "count"
      type: "integer"
      category: "performance"
      description: "Number of detection boxes in last image"
      
    - name: "total_processed"
      command: "get_latest_metrics"
      unit: "count"
      type: "integer"
      category: "performance"
      description: "Total images processed since start"
  
  # System resource metrics
  system_metrics:
    - name: "cpu_usage"
      command: "get_latest_metrics"
      unit: "percent"
      type: "float"
      category: "system"
      description: "Current CPU utilization"
      
    - name: "memory_usage"
      command: "get_latest_logs"
      unit: "percent"
      type: "float"
      category: "system"
      description: "Current memory utilization"

  
  # Model state metrics
  model_metrics:
    - name: "current_model"
      command: "get_current_model"
      unit: "string"
      type: "string"
      category: "model"
      description: "Currently active YOLO model"
      
    - name: "model_switch_count"
      command: "get_system_state"
      unit: "count"
      type: "integer"
      category: "model"
      description: "Number of model switches performed"
  
  # Derived metrics (calculated from base metrics)
  derived_metrics:
    - name: "cpu_efficiency"
      formula: "(1.0 / image_processing_time) / (cpu_usage / 100.0) if cpu_usage > 0 and image_processing_time > 0 else 0"
      unit: "efficiency_ratio"
      category: "derived"
      description: "Processing efficiency relative to CPU usage"
      
    - name: "detection_rate"
      formula: "detection_boxes / image_processing_time if image_processing_time > 0 else 0"
      unit: "detections_per_second"
      category: "derived"
      description: "Detection rate per second"
      
    - name: "system_load_factor"
      formula: "min(cpu_usage / 100.0, 1.0) if cpu_usage > 0 else 0"
      unit: "ratio"
      category: "derived"
      description: "Normalized system load factor"
      

# =============================================================================
# Meta Learner Configuration for SWITCH System
# =============================================================================
meta_learner:
  # Agent identification
  agent_id: "switch_meta_learner"
  implementation: "example"  # or "llm" for LLM-based meta learner
  
  # HIGH FREQUENCY CONFIGURATION for Switch System
  triggers:
    # INCREASED FREQUENCY: Every 5 minutes instead of default 6 hours
    periodic:
      enabled: true
      interval_minutes: 5           # ⚡ HIGH FREQUENCY: Every 5 minutes
      analysis_window_hours: 2.0    # Shorter analysis window for faster learning
      
    # Performance-driven triggers for utility optimization
    performance_driven:
      enabled: true
      utility_drop_threshold: 0.1   # Trigger if utility drops by 10%
      response_time_spike_threshold: 2.0  # Trigger if RT > 2x normal
      confidence_drop_threshold: 0.15     # Trigger if confidence drops 15%
      
    # Event-driven triggers for model switches
    event_driven:
      enabled: true
      model_switch_frequency_threshold: 10  # Trigger if >10 switches/hour
      utility_spiral_threshold: 0.2         # Trigger if utility < 0.2
      
    # Threshold violation triggers
    threshold_violation:
      enabled: true
      cpu_threshold: 90.0           # Trigger if CPU > 90%
      response_time_threshold: 1.5  # Trigger if RT > 1.5s
  
  # Learning configuration optimized for SWITCH
  learning:
    # SWITCH-specific parameters
    min_confidence_threshold: 0.6    # Lower threshold for ML experimentation
    analysis_window_hours: 2.0       # Shorter window for faster adaptation
    calibration_frequency_minutes: 15 # ⚡ HIGH FREQUENCY: Every 15 minutes
    
    # SWITCH utility function focus areas
    focus_areas:
      - "utility_optimization"
      - "model_switching_patterns"
      - "response_time_trends"
      - "confidence_accuracy_tradeoffs"
      - "cpu_resource_management"
    
    # Parameter update constraints for SWITCH
    parameter_constraints:
      utility_weights:
        min_response_time_weight: 0.4  # Keep RT weight >= 40%
        max_response_time_weight: 0.8  # Keep RT weight <= 80%
        min_confidence_weight: 0.2     # Keep confidence weight >= 20%
        max_confidence_weight: 0.6     # Keep confidence weight <= 60%
      
      thresholds:
        min_utility_target: 0.5        # Don't lower utility target below 0.5
        max_cpu_threshold: 95.0        # Don't raise CPU threshold above 95%
        min_response_time_threshold: 0.1  # Don't lower RT threshold below 0.1s
  
  # SWITCH-specific adaptation parameters to learn
  adaptation_parameters:
    # Utility function weights (primary focus)
    utility_function:
      response_time_weight: 0.6      # Current: favor speed slightly
      confidence_weight: 0.4         # Current: secondary priority
      penalty_factors:
        response_time_penalty: 2.0   # Current: reduced from 5.0
        confidence_penalty: 2.0      # Current: reduced from 5.0
    
    # Model switching thresholds
    switching_thresholds:
      utility_low_threshold: 0.3     # Current: trigger optimization
      utility_critical_threshold: 0.1  # Current: emergency action
      cpu_high_threshold: 80.0       # Current: consider lighter model
      cpu_critical_threshold: 90.0   # Current: emergency downgrade
      response_time_high: 0.8        # Current: consider downgrade
      response_time_critical: 1.5    # Current: emergency downgrade
    
    # Controller strategy parameters
    controller_strategy:
      optimization_interval: 15      # Current: slow controller every 15 actions
      min_switch_interval: 3.0       # Current: minimum seconds between switches
      max_switches_per_hour: 20      # Current: rate limiting
  
  # Knowledge base integration
  knowledge_base:
    query_subjects:
      - "polaris.switch.metrics"
      - "polaris.switch.model_events"
      - "polaris.switch.utility"
      - "polaris.execution.results"
    
    # Data types to analyze
    data_types:
      - "observation"           # System snapshots
      - "adaptation_decision"   # Controller actions
      - "raw_telemetry_event"  # Individual metrics
    
    # Query parameters
    max_query_results: 200      # Larger dataset for ML analysis
    query_timeout_sec: 30
  
  # Digital twin integration for calibration
  digital_twin:
    calibration_enabled: true
    calibration_metrics:
      - "utility"
      - "image_processing_time"
      - "confidence"
      - "cpu_usage"
    
    # Simulation for parameter validation
    validation_simulations:
      enabled: true
      simulation_horizon_minutes: 10
      validation_threshold: 0.7  # Require 70% confidence for updates
  
  # Performance and resource limits
  performance:
    max_concurrent_analyses: 2
    analysis_timeout_minutes: 5
    max_memory_usage_mb: 512
    enable_caching: true
    cache_ttl_minutes: 30
  
  # Logging and monitoring
  monitoring:
    log_level: "INFO"
    enable_detailed_logging: true
    metrics_collection: true
    performance_tracking: true
    
    # Meta learner specific metrics
    track_metrics:
      - "learning_cycles_completed"
      - "parameter_updates_applied"
      - "calibration_improvements"
      - "utility_trend_accuracy"
      - "adaptation_success_rate"

# =============================================================================
# Bayesian World Model Configuration for SWITCH
# =============================================================================
bayesian_switch_config:
  # SWITCH-specific parameters
  prediction_horizon_minutes: 20    # Shorter horizon for ML workloads
  max_history_points: 300           # Sufficient for pattern learning
  update_interval_seconds: 30       # Match SWITCH telemetry rate
  
  # SWITCH-tuned statistical thresholds
  correlation_threshold: 0.65       # Moderate threshold for ML metrics
  anomaly_threshold: 100.0            # Less sensitive (ML metrics vary)
  prior_confidence: 0.4             # Moderate prior for ML behavior
  learning_rate: 0.15               # Higher rate for dynamic ML patterns
  
  # SWITCH-optimized Kalman filter parameters
  process_noise: 0.08               # Higher noise for ML variability
  measurement_noise: 0.06           # Moderate measurement noise
  initial_uncertainty: 0.6          # Higher initial uncertainty
  
  # Performance settings
  max_concurrent_operations: 6
  computation_timeout_sec: 20
